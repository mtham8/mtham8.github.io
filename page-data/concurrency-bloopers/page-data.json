{"componentChunkName":"component---src-templates-blog-post-js","path":"/concurrency-bloopers/","webpackCompilationHash":"66f0d500963bcf289869","result":{"data":{"site":{"siteMetadata":{"title":"mic(s)","author":"Michelle"}},"markdownRemark":{"id":"b772a6e9-e740-5065-be8a-b0e9801064df","excerpt":"Earlier this week, I ran into a bug that I couldn’t quite understand. The code looked a bit like this https://play.golang.org/p/29mw6PEDm2t My task was to…","html":"<p>Earlier this week, I ran into a bug that I couldn’t quite understand. The code looked a bit like this</p>\n<p><a href=\"https://play.golang.org/p/29mw6PEDm2t\">https://play.golang.org/p/29mw6PEDm2t</a></p>\n<p>My task was to create a program that fetches data, processes it, and then loads the data into a database.\nMy initial thought was, okay, let’s think about this in terms of streams. A stream of incoming data flows in through\na channel - let’s call that channel, <code class=\"language-text\">received</code>. Some function will then read off of <code class=\"language-text\">received</code> and process each item in that channel, and then send the result to a stream of processed data, or to a channel called, <code class=\"language-text\">processed</code>. Some other function will then read off of <code class=\"language-text\">processed</code> and either load it to a database, or in the playground example, simply print out what was processed. Thinking in streams allowed me to decouple data structures from upstream and downstream processes.</p>\n<p>However, when I ran the program, I thought the results were quite weird. There was no errors, no race condition, but the only channel being read was the <code class=\"language-text\">received</code> channel. Then the <code class=\"language-text\">processed</code> channel was read afterwards. Hm. That was not what I was expecting. The code that ran behaved synchronously, despite the fact that the mental model in my mind, was concurrent.\nI was expecting one datum to be sent to the <code class=\"language-text\">received</code> channel, and then consequently, in order for the <code class=\"language-text\">received</code> channel to send another datum, <code class=\"language-text\">processed</code> channel would be read.</p>\n<p>After a couple hours of debugging, I saw one minor but enormous bug. Here is the correction, based on the example above</p>\n<p><a href=\"https://play.golang.org/p/PUx_TXX6esV\">https://play.golang.org/p/PUx_TXX6esV</a></p>\n<p>I was reading off the <code class=\"language-text\">received</code> channel on the same thread as reading off the <code class=\"language-text\">processed</code> channel. Therefore, <code class=\"language-text\">processed</code> could not be read until <code class=\"language-text\">received</code> was closed. The solution was to wrap reading off the <code class=\"language-text\">received</code> channel in a goroutine so that each channel can be read in its own thread/goroutine.</p>\n<p>Concurrency is complex. Always make sure to verify if the code written reflects the mental model correctly. If you’re going to return a channel, wrap the process that sends to that channel in a goroutine.</p>","frontmatter":{"title":"Concurrency Bloopers","date":"July 21, 2019","description":"If you're going to return a channel, wrap the process that sends to that channel in a goroutine..."}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/concurrency-bloopers/","previous":{"fields":{"slug":"/merge-channels/"},"frontmatter":{"title":"Let's Merge Channels"}},"next":null}}}