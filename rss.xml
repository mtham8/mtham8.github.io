<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[mic(s)]]></title><description><![CDATA[A place for thoughts to roam free.]]></description><link>https://mtham8.github.io/</link><generator>RSS for Node</generator><lastBuildDate>Fri, 07 Feb 2020 20:50:32 GMT</lastBuildDate><item><title><![CDATA[Concurrency Bloopers]]></title><description><![CDATA[Earlier this week, I ran into a bug that I couldn’t quite understand. The code looked a bit like this https://play.golang.org/p/29mw6PEDm2t…]]></description><link>https://mtham8.github.io//concurrency-bloopers/</link><guid isPermaLink="false">https://mtham8.github.io//concurrency-bloopers/</guid><pubDate>Sun, 21 Jul 2019 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;Earlier this week, I ran into a bug that I couldn’t quite understand. The code looked a bit like this&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/29mw6PEDm2t&quot;&gt;https://play.golang.org/p/29mw6PEDm2t&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;My task was to create a program that fetches data, processes it, and then loads the data into a database.
My initial thought was, okay, let’s think about this in terms of streams. A stream of incoming data flows in through
a channel - let’s call that channel, &lt;code class=&quot;language-text&quot;&gt;received&lt;/code&gt;. Some function will then read off of &lt;code class=&quot;language-text&quot;&gt;received&lt;/code&gt; and process each item in that channel, and then send the result to a stream of processed data, or to a channel called, &lt;code class=&quot;language-text&quot;&gt;processed&lt;/code&gt;. Some other function will then read off of &lt;code class=&quot;language-text&quot;&gt;processed&lt;/code&gt; and either load it to a database, or in the playground example, simply print out what was processed. Thinking in streams allowed me to decouple data structures from upstream and downstream processes.&lt;/p&gt;
&lt;p&gt;However, when I ran the program, I thought the results were quite weird. There was no errors, no race condition, but the only channel being read was the &lt;code class=&quot;language-text&quot;&gt;received&lt;/code&gt; channel. Then the &lt;code class=&quot;language-text&quot;&gt;processed&lt;/code&gt; channel was read afterwards. Hm. That was not what I was expecting. The code that ran behaved synchronously, despite the fact that the mental model in my mind, was concurrent.
I was expecting one datum to be sent to the &lt;code class=&quot;language-text&quot;&gt;received&lt;/code&gt; channel, and then consequently, in order for the &lt;code class=&quot;language-text&quot;&gt;received&lt;/code&gt; channel to send another datum, &lt;code class=&quot;language-text&quot;&gt;processed&lt;/code&gt; channel would be read.&lt;/p&gt;
&lt;p&gt;After a couple hours of debugging, I saw one minor but enormous bug. Here is the correction, based on the example above&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/PUx_TXX6esV&quot;&gt;https://play.golang.org/p/PUx_TXX6esV&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I was reading off the &lt;code class=&quot;language-text&quot;&gt;received&lt;/code&gt; channel on the same thread as reading off the &lt;code class=&quot;language-text&quot;&gt;processed&lt;/code&gt; channel. Therefore, &lt;code class=&quot;language-text&quot;&gt;processed&lt;/code&gt; could not be read until &lt;code class=&quot;language-text&quot;&gt;received&lt;/code&gt; was closed. The solution was to wrap reading off the &lt;code class=&quot;language-text&quot;&gt;received&lt;/code&gt; channel in a goroutine so that each channel can be read in its own thread/goroutine.&lt;/p&gt;
&lt;p&gt;Concurrency is complex. Always make sure to verify if the code written reflects the mental model correctly. If you’re going to return a channel, wrap the process that sends to that channel in a goroutine.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Let's Merge Channels]]></title><description><![CDATA[I encountered a situation while writing an application for text extraction,
where I fan-out to process files based on file extension types…]]></description><link>https://mtham8.github.io//merge-channels/</link><guid isPermaLink="false">https://mtham8.github.io//merge-channels/</guid><pubDate>Sat, 06 Jul 2019 22:12:03 GMT</pubDate><content:encoded>&lt;p&gt;I encountered a situation while writing an application for text extraction,
where I fan-out to process files based on file extension types, but then needed a
way to fan-in the results to a single channel of responses for some consumer.&lt;/p&gt;
&lt;p&gt;After doing some open-source research (googling), I discovered go had a convenient way
of merging channels, which in this case, was processed data channels produced by each file extension type (struct)
that implemented the file processor interface.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;go&quot;&gt;&lt;pre class=&quot;language-go&quot;&gt;&lt;code class=&quot;language-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;mergeChannels&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cs &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;chan&lt;/span&gt; ProcessorInterface&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;chan&lt;/span&gt; ProcessorInterface &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	outChan &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;chan&lt;/span&gt; ProcessorInterface&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;var&lt;/span&gt; wg sync&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;WaitGroup
	wg&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

	&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; c &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;range&lt;/span&gt; cs &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;channel &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;chan&lt;/span&gt; ProcessorInterface&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;token keyword&quot;&gt;defer&lt;/span&gt; wg&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Done&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; val &lt;span class=&quot;token operator&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;range&lt;/span&gt; channel &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
				outChan &lt;span class=&quot;token operator&quot;&gt;&amp;lt;-&lt;/span&gt; val
			&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;c&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

	&lt;span class=&quot;token keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		wg&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;Wait&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;token function&quot;&gt;close&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;outChan&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; outChan
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</content:encoded></item></channel></rss>